(let (test-code (assemble '((PUSH 1)
                            (PUSH 2)
                            (CONS))))
  ;;(prn "Running test bytecode:")
  ;;(prn test-code)
  (let (val (run-bytecode test-code))
    (assert= (car val) 2)
    (assert= (cdr val) 1)))

(let (test-code (assemble `((PUSH nil)
                            (PUSH 2)
                            (CONS)
                            (PUSH 2)
                            (CONS)
                            (CALL_BUILTIN ,+))))
  ;;(prn "Running test bytecode:")
  ;;(prn test-code)
  ;;(prn (run-bytecode test-code)))
  (assert= (run-bytecode test-code) 4))

;; TODO: hack. CALL pushes the return addr, we don't use that so we just pop it
(let (test-code-func (assemble `((POP)
                                 (CONS)
                                 (PUSH 1)
                                 (CONS)
                                 (CALL_BUILTIN ,+))))
  (let (test-code (assemble `((PUSH nil)
                              (PUSH nil)
                              (PUSH 2)
                              (CONS)
                              (PUSH 2)
                              (CONS)
                              (CALL_BUILTIN ,+)
                              (CALL ,test-code-func))))
    ;;(assert (sym= (type test-code-func) 'bytecode))
    ;;(prn "Running test bytecode:")
    ;;(prn test-code)
    ;;(prn "Function to call:")
    ;;(prn test-code-func)
    ;;(prn (run-bytecode test-code))))
    (assert= (run-bytecode test-code) 5)))

(let (test-code (assemble `((PUSH nil)
                            (PUSH 2)
                            (CONS)
                            (PUSH 2)
                            (CONS)
                            (PUSH true)
                            (JIF 9)
                            (PUSH "This should be skipped")
                            (CALL_BUILTIN ,prn)
                            (CALL_BUILTIN ,+))))
  ;;(prn "Running test bytecode:")
  ;;(prn test-code)
  (assert= (run-bytecode test-code) 4))
